;
; LIGHTHOUSE OF DOOM!!!
;
; Steve Kemp
; -
; https://steve.kemp.fi/
;
; https://github.com/skx/lighthouse-of-doom
;


;
; This is a port of the lighthouse-of-doom game from C to Z80 assembly, such
; that it will run under CP/M 2.x
;
; Although the game has been ported that process has resulted in some changes
; to the text, and the command-handlers.  If you've played the C game, and
; completed it, there will be no significant new surprises.
;
; Rather than having a global player-inventory store, and a place
; in each location for object storage we've instead make the location
; a property of each item.
;
; Known deficiencies & bugs:
;
;   HELP command doesn't show description next to command.
;
;   When we change the item-size we have to mess around a lot with pointer
;   changes.  Lack of real structures hurt here - but I'm too invested now
;   to look for a new compiler
;
;   "TAKE RUG" will always move a trapdoor into play - but should only do
;   so in the basement location.
;



; BIOS entry-point
BDOS_ENTRY_POINT:    EQU 5

; BIOS functions we call
BDOS_CHARACTER_READ:  EQU 0x01
BDOS_OUTPUT_STRING:  EQU 0x09
BDOS_READ_INPUT:     EQU 0x0A
BDOS_OUTPUT_SINGLE_CHARACTER: EQU 0x02


        ORG 100h

        ;
        ; Our game can be compiled with optional "encryption", which uses
        ; a simple scheme to hide the strings in our binary.
        ;
        ; If this support is used we'll have to restore our contents, or
        ; the game won't be playable.
        ;
        ; To compile the binary with encryption you need to define the
        ; `ENCRYPT_STRINGS` symbol, and then post-process the binary
        ; with `encrypt.c`.
        ;
IF ENCRYPT_STRINGS
        ld hl, ENC                      ; start of region to unmangle
        ld de, ( end_of_source - ENC )  ; length to unmangle.
        ld c, '%'                       ; starting scrambling key (XOR)
enc_loop:
        ld a,(hl)          ; get the byte
        xor c              ; modify it
        ld (hl),a          ; store it back
        inc hl             ; point to the next byte
        dec de             ; decrease count of remaining bytes to process.
        inc c              ; bump key
        ld a, d            ; done?
        or e
        jr nz,enc_loop     ; no, then repeat


        jp enc_end         ; Jump over our marker to the start of the game.

        ;
        ; Everything after here will be encrypted.
        ;
        ENC: DB "SKX"
enc_end:
ENDIF

        ; Clear the screen
        call cls_function

        ; Present the game intro-text.
        ld de, usage_message
        ld c, BDOS_OUTPUT_STRING
        call BDOS_ENTRY_POINT

        ; Pause for input here.
        ld c,BDOS_CHARACTER_READ
        call BDOS_ENTRY_POINT
        call cls_function

        ; Show the starting-location.
        call show_newline
        ld hl, input_buffer+2
        ld a, 'L'
        ld (hl), a
        call look_function

        ; The start of our game loop.
        ;
        ; Here we basically read a line of input, attempt to call the
        ; appropriate handler and then repeat.
        ;
        ; We upper-case all input to allow easier matching to our
        ; command/dispatch-table.
game_loop:

        ; 0. Have we died?
        ld hl, TURN_COUNT
        ld a, (hl)
        cp 50
        jp c,game_loop_continue

        ld HL, PLAYER_DEAD
        inc (hl)

game_loop_continue:

        ; 1. Is the player dead?
        ld hl, PLAYER_DEAD
        ld a, (hl)
        cp 1
        jp nz,not_dead

        ; The player is dead.  Oops.
        ld de, PLAYER_DEAD_MESSAGE
        call show_msg
        call show_turn_count
        jp 0x0000

not_dead:
        ; 2. Did the player win?
        ld hl, PLAYER_WON
        ld a, (hl)
        cp 1
        jp nz, not_won

        ; The player won.  Yay!
        ld de, PLAYER_WON_MESSAGE
        call show_msg
        call show_turn_count
        jp 0x0000

not_won:
        ; 3. show the prompt
        ld de, prompt_message
        ld c, BDOS_OUTPUT_STRING
        call BDOS_ENTRY_POINT

        ; 4. Erase our input buffer.
        ld hl, input_buffer+2
        ld b, 0xff
        call erase_buffer

        ; 5. Read a line of input from the player.
        ld de, input_buffer
        ld c, BDOS_READ_INPUT
        call BDOS_ENTRY_POINT

        ; If the input was zero-length (i.e. User pressed return) ignore it.
        ld hl, input_buffer+1
        ld a,(hl)
        cp 0
        jr z, not_won

        ; 6. Convert the input to upper-case.
        ld b,a
        inc hl
        call uppercase_buffer

        ;  7.  Take the input from the user, and see if we have a registered
        ; command with that name.  If we do we can invoke it, but if not we've
        ; been given something we don't understand.
        ld hl, input_buffer+2
        call find_command
        cp 255
        jp z, no_handler

        ; Call the handler
        call JP_HL

        ; Valid command - increase turn count
        ld hl, TURN_COUNT
        inc (hl)

        ; And restart the command-loop
        jp game_loop


no_handler:
        ; Show the user that their command wasn't understood.
        ld de, invalid_msg
        call show_msg

        ; Invalid command, but this is still a turn
        ld hl, TURN_COUNT
        inc (hl)

        ;  8.  Goto 1
        jp game_loop              ; restart





; This will be a major part of our code so it is perhaps a little more
; verbose than it wants to be.
;
; Find the entry in the command-table.  If we find it return the address
; of the routine to call in `HL`.
;
; On entry `HL` should contain the pointer to the input buffer to look
; for.
;
; On exit A contains 0 on success, with HL pointing to the handler to invoke,
; or A contains 255 on failure.
find_command:
        ld de,command_table

        ;
        ; Entries are arranged like so:
        ;   $LENGTH "ASCII" $HIDDEN ADDR1 ADDR2
        ;
        ; Where $LENGTH is the length of the ASCII command-name.
        ;
        ; So:
        ;
        ;   4, "QUIT", 0, quit_fn_ptr
        ;   3, "CLS",  1, cls_fn_ptr
        ;   0,
        ;
        ; "HIDDEN" is used solely to decide whether the command should be
        ; included in the output of "HELP".
        ;
find_command_again:
        push de
        ld a, (de)  ; length of string
        cp 0x00     ; zero?  We've hit the end of the table and not found
        jr nz, cont ; a match - return failure
        pop de
        ld a,255
        ret
cont:
        ld b, a    ; B will contain the length
        inc de     ; DE point to the string itself

        push hl
        call CompareStringsWithLength
        jp z,find_command_found
        pop hl

        ; ok we didn't find
        pop de
        ld a, (de)
        inc de
        ld b,a
find_command_skip:
        inc de
        djnz find_command_skip
        inc de ; hidden-flag
        inc de ; addr1
        inc de ; addr2
        ; next entry - might be zero-terminated
        jp  find_command_again

find_command_found:
        pop hl
        pop de ; points to the length before the entry

        ld a, (de) ; get the length
        inc de     ; move to the start of the string
        ld b,a
find_command_skip2:    ; skip length-bytes
        inc de
        djnz find_command_skip2
        inc de ; skip the hidden-flag
        ld a, (de)  ; set l
        ld l,a
        inc de
        ld a, (de)  ; set h
        ld h,a
        ld a,0      ; indicate success
        ret         ; return with the function-pointer in HL


; compare strings stored in HL + DE for equality.  Length is stored in B
; Returns NZ if they're not equal.
CompareStringsWithLength:
    ld a,(de)
    cp (hl)
    ret nz     ;nz means they are not equal
    inc hl
    inc de
    djnz CompareStringsWithLength
    ld a,0
    ret


;
; Helper function, to allow indirection.
;
JP_HL:
        ld bc, ret_obj
        push bc
	push hl
ret_obj:
        ret


;
; Helper function, fill a region of memory with zero characters
;
;  HL will point to the buffer.
;   B will have the length
erase_buffer:
        xor a
erase_buffer_loop:
        ld (hl),a
        inc hl
        djnz erase_buffer_loop
        ret


;
; Helper function.  Upper-case the given string.
;
;  HL will point to the buffer.
;   B will have the length
;
uppercase_buffer:
        ld a, (hl)
        cp 'a'-1
        jr c, uppercase_ok
        cp 'z'+1
        jr nc, uppercase_ok
        sub 32
        ld (hl),a
uppercase_ok:
        inc hl
        djnz uppercase_buffer
        ret

;
; Helper function.  Are ANY items present in this room?
;
; This is just used to know whether to print the "You can see .." message
;
; Return "A == 0" if so.
; Return "A == FF" if not
;
items_are_present:
        ld hl, items
        ld b, ITEM_COUNT
look_item_loop_test:
        push hl
        ld hl, CURRENT_LOCATION
        ld a,(hl)
        pop hl

        ; hl points to the item
        ; skip past the name
        inc hl
        inc hl
        ; skip past the description - saving it
        ld e, (hl)
        inc hl
        ld d, (hl)
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ; skip past the drop-handler
        inc hl
        inc hl
        ; skip past the use-handler
        inc hl
        inc hl
        ; skip past the "collectable" property
        inc hl
        ld c,(hl)  ; is this present in the current location?
        cp c
        jr nz, item_not_present_loop

        ; OK we have an item present.  Is the description empty?
        ; if so that's a hidden object
        ld a, d
        or e
        jr z, item_not_present_loop

        xor a
        ret
item_not_present_loop:
        inc hl
        djnz look_item_loop_test
        ld a, 0xff
        ret


;
; Helper function.  Get item by name
;
; Name will be stored in HL
;
; On exit A will be 00 if all is OK, and HL will point to the item.
; On exit A will be ff if there was a failure.
;
get_item_by_name:

        push hl

        ; erase our temporary buffer
        ld hl, tmp_buffer
        ld b,TMP_BUFFER_LEN
        call erase_buffer

        ; copy the name of the item into the temporary-buffer, we add
        ; a prefixed of the length.
        pop hl
        ld de,tmp_buffer+1
        ld b,0
gibn_copy_loop:
        ld a,(hl)
        cp 0
        jr z, gibn_copy_complete
        ld (de),a
        inc de
        inc hl
        inc b
        jr gibn_copy_loop

gibn_copy_complete:
        ld hl, tmp_buffer
        ld (hl),b

        ; point to the item-table
        ld hl, items
        ld b, ITEM_COUNT

gibn_item_loop:
        ; HL points to the item
        ; Get the name in DE
        ld e,(hl)
        inc hl
        ld d,(hl)
        inc hl

        ; skip past the desc
        inc hl
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ; skip past the drop-handler
        inc hl
        inc hl
        ; skip past the use-handler
        inc hl
        inc hl
        ; skip past the "collectable" property
        inc hl

        ; is this object carried, in the current location, or
        ; otherwise available?
        ld a,(hl)
        cp 0xFF ; 0xff means the item is being carried
        jr z, gibn_item_carried
        cp 0xFE ; 0xfe means the item can be found.
        jr z, gibn_item_available
        push hl
        ld hl, CURRENT_LOCATION
        ld c,(hl)
        pop hl
        cp c
        jr z, gibn_item_present

gibn_continue:
        inc hl
        djnz gibn_item_loop
        ld a, 0xff
        ret

gibn_item_present:
gibn_item_carried:
gibn_item_available:
        push hl ; preserve our entry into the item
        push bc ; preserve b for our loop

        ld hl, tmp_buffer ; Get the length from our buffer
        ld b, (hl)
        inc hl            ; Now HL points to the input
                          ; DE points to the name of the current item.
        call CompareStringsWithLength
        jp z, gibn_found_it

        pop bc
        pop hl
        jr gibn_continue

gibn_found_it:
        pop bc
        pop hl

        dec hl ; yeah this is bad.
        dec hl ; we're decreasing HL to point back to the start of this item.

        dec hl
        dec hl

        dec hl
        dec hl

        dec hl
        dec hl

        dec hl
        dec hl

        dec hl
        xor a
        ret


;
; Helper function.  Is the player carrying something?
;
; This is used in the inventory function to decide whether to show the list
; of items, with header, or "You're carrying nothing".
;
; Return "A == 0" if so.
; Return "A == FF" if not.
;
player_has_objects:
        ld hl, items
        ld b, ITEM_COUNT
player_has_objects_loop:
        ; hl points to the item
        ; skip past the name
        inc hl
        inc hl
        ; skip past the description
        inc hl
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ; skip past the drop-handler
        inc hl
        inc hl
        ; skip past the use-handler
        inc hl
        inc hl
        ; skip past the "collectable" property
        inc hl
        ld a,(hl)
        cp 255
        jr nz, player_not_carrying_loop
        xor a
        ret
player_not_carrying_loop:
        inc hl
        djnz player_has_objects_loop
        ld a, 0xff
        ret



;
; Helper function - get pointer to second command-line word
;
; e.g. The user enters "GET TORCH", "EXAMINE BOOK", etc, we want to
; get the start of second-word "TORCH", "BOOK"
;
input_second_term:
        ld hl, input_buffer+2

        ; start be incrementing the pointer until we find a space
input_second_term_loop1:
        ld a,(hl)
        cp 0
        jp z,input_second_term_end
        cp ' '
        jp z, input_second_term_found_space
        inc hl
        jp input_second_term_loop1

        ; At this point HL points to " "
input_second_term_found_space:
        ld a,(hl)
        cp 0
        jp z,input_second_term_end
        cp ' '
        jp nz, input_second_term_found_word
        inc hl
        jp input_second_term_found_space

input_second_term_found_word:
        ; HL points to the word
        ld a,0
        ret

input_second_term_end:
        ld a, 0xff
        ret


;
; Show a message, terminated with "$"
;
; Address in DE
;
show_msg:
        ld c, BDOS_OUTPUT_STRING
        call BDOS_ENTRY_POINT
        ret



; Multiply two 8-bit values together.
; INPUT: THE VALUES IN REGISTER B EN C
; OUTPUT: HL = B * C
; CHANGES: AF,DE,HL,B
;
multiply:
	LD HL,0
	LD A,B
	OR A
	RET Z
	LD D,0
	LD E,C
LOOP:	ADD HL,DE
	DJNZ LOOP
	RET

;
; Output number helpers - used solely for reporting the number of turns
; you have taken.
;
; (Either at victory/death, or via the TURNS command.)
;
DispHL:
	ld	bc,-10000
	call	Num1
	ld	bc,-1000
	call	Num1
	ld	bc,-100
	call	Num1
	ld	c,-10
	call	Num1
	ld	c,-1
Num1:	ld	a,'0'-1
Num2:	inc	a
	add	hl,bc
	jr	c,Num2
	sbc	hl,bc
        push hl
        push de
        push bc
        push af

        ld c, BDOS_OUTPUT_SINGLE_CHARACTER
        ld e, a
        call BDOS_ENTRY_POINT

        pop af
        pop bc
        pop de
        pop hl
	ret

show_a_register:
        push hl
        push de
        push bc
        push af
        ld h,0
	ld l,a
	call DispHL
        pop af
        pop bc
        pop de
        pop hl
        ret


;
; Show the number of turns a user has played
;
show_turn_count:
        call show_newline
        ld de, PLAYER_TURN_COUNT
        call show_msg
        ld hl, TURN_COUNT
        ld a, (hl)
        inc a
        call show_a_register
        ld de, PLAYER_TURN_COUNT_END
        call show_msg
        ret




;********************************************************************
; Command Handlers
;********************************************************************



;
; Command-Handler SWEARING
;
bad_language_function:
        ld de, BAD_LANGUAGE_MSG
        jp show_msg

;
; Command-Handler CLS
;
;  Clear the screen
cls_function:
        ld de, CLS_MSG
        jp show_msg

;
; Command-Handler DOWN
;
; Change location, this has some tests
;
down_function:
        ld hl, CURRENT_LOCATION
        ld a, (hl)
        cp 0
        jr z, down_on_top_floor
        cp 1
        jr z, down_on_middle_floor
        cp 2
        jr z, down_on_ground_floor

        ; fall-through other options will show "NO DOWN"
no_down:
        ld de, no_down_msg
        call show_msg
        ret

down_on_top_floor:
down_on_middle_floor:
        inc (hl)
        call look_function
        ret

down_on_ground_floor:
        ; find the trapdoor-open - if it isn't there you can't go down
        ld hl, item_12_name
        call get_item_by_name
        cp 0
        jr z, down_found_trap

        ld de, failed_find_trapdoor_open_msg
        call show_msg
        ret
down_found_trap:

        ; skip past the name
        inc hl
        inc hl
        ; skip past the short description
        inc hl
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ; skip past the drop-function.
        inc hl
        inc hl
        ; skip past the use-function
        inc hl
        inc hl
        ; skip past the "collectable" property
        inc hl

        ld a,(hl) ; get the location of the trapdoor
        cp 2
        jr nz, no_down ; not on the basement?  Then we can't go down

        ; Does the user have the torch-lit?
        ;
        ; Note that if we can't find the torch that is because it
        ; is not in the current locaton OR the player isn't carrying it
        ;
        ; That's OK, that just means they go to the dark place.
        ld hl, item_4_name
        call get_item_by_name
        cp 0
        jp nz, dark_destination

        ; found the torch

        ; skip past the name
        inc hl
        inc hl
        ; skip past the short description
        inc hl
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ; skip past the drop-function.
        inc hl
        inc hl
        ; skip past the use-function
        inc hl
        inc hl
        ; skip past the "collectable" property
        inc hl

        ; is the player carrying it?
        ld a,(hl)
        cp 255
        jr nz,dark_destination

        ld hl,CURRENT_LOCATION
        ld (hl),3
        call look_function
        ret
dark_destination:
        ld hl,CURRENT_LOCATION
        ld (hl),4
        call look_function
        ret




;
; Command-Handler DROP
;
; If the item is carried by the player it is dropped
;
; If there is a non-zero drop-function it is invoked.
;
drop_function:
        call input_second_term
        cp 0
        jp z, drop_object

        ld de, DROP_WHAT_MSG
        call show_msg
        ret

drop_object:
        ; store object in HL
        call input_second_term

        call get_item_by_name
        cp 0
        jp z,drop_found_it

        ; if we didn't find it in the current location or inventory
        ; then we're not carrying it.
        ld de, not_carrying_item_msg
        call show_msg
        ret

drop_found_it:
        ; skip past the name
        inc hl
        inc hl
        ; skip past the short description
        inc hl
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ; skip past the drop-function - but save it in DE
        ld e,(hl)
        inc hl
        ld d,(hl)
        inc hl
        ; skip past the use-function
        inc hl
        inc hl
        ; skip past the "collectable" property
        inc hl

        ; save the current location in this slot, so it is
        ; now dropped
        push hl
        ld hl, CURRENT_LOCATION
        ld a,(hl)
        pop hl
        ld (hl),a

        ; is the handler empty?
        ld a, d
        or e
        jr nz, drop_invoke_handler
        ld de, you_drop_it
        call show_msg
        ret

drop_invoke_handler:
        push de
        pop hl
        call JP_HL
        ret




;
; Command-Handler EXAMINE
;
; Examine either:
;
;   1.  An item in the current location.
;
;   2.  An item in the users' inventory.
;
; Examination means:
;
;   1.  Identify the object from the input-buffer
;   2.  Check if the object exists, and if so
;   3.  Show the extended-description
;
examine_function:
        call input_second_term
        cp 0
        jp z, examine_object

        ld de, EXAMINE_WHAT_MSG
        call show_msg
        ret

examine_object:
        call show_newline

        ; store object in HL
        call input_second_term

        call get_item_by_name
        cp 0
        jp z,examine_found_it

        ld de, item_not_present_msg
        call show_msg
        ret

examine_found_it:
        ; skip past the name
        inc hl
        inc hl
        ; skip past the short description
        inc hl
        inc hl
        ; get the long description
        ld e,(hl)
        inc hl
        ld d,(hl)
        inc hl
        call show_msg
        ret


;
; Command-Handler CALL
;
; If we're in the middle-floor we can use the telephone
;
call_function:
        ld hl,CURRENT_LOCATION
        ld a,(hl)
        cp 1
        jr z, call_proceed

        ; not in the phone-room?  Show an error and return
        ld de, NO_PHONE_HERE
        call show_msg
        ret

call_proceed:
        call input_second_term
        cp 0
        jp z, call_person

        ; missing person
        ld de, CALL_WHO_MSG
        call show_msg
        ret

call_person:
        ; HL points to the person the user tried to call
        ; look in our people-table to see if there is a response
        ; we can make
        ld de, people_table
next_person_test:
        push de
        ld a, (de)       ; length of string
        cp 0x00          ; zero?  We've hit the end of the table and not found
        jr nz, cont_call ; a match - show a failure message and return

        ; show the error-message and return
        pop de
        ld de, call_unknown_msg
        call show_msg
        ret

        ; OK we've got an entry
cont_call:
        ld b, a    ; B will contain the length
        inc de     ; DE point to the string itself

        push hl
        call CompareStringsWithLength
        jp z, found_person_to_call
        pop hl

        ; ok we didn't find
        pop de

        ; ok we didn't find
        ld a, (de)
        inc de     ; get the entry-length
        ld b,a
skip_string:
        inc de
        djnz skip_string
        inc de ; addr1
        inc de ; addr2
        jp next_person_test

found_person_to_call:
        pop hl
        pop de
        ld a, (de)
        inc de     ; get the entry-length
        ld b,a
skip_string2:
        inc de
        djnz skip_string2
        push de
        pop hl
        ld e, (hl)
        inc hl
        ld d, (hl)
        call show_msg
        ret

;
; Command-Handler GET
;
get_function:
        call input_second_term
        cp 0
        jp z, get_object

        ld de, GET_WHAT_MSG
        call show_msg
        ret

get_object:
        ; store object in HL
        call input_second_term

        call get_item_by_name
        cp 0
        jp z,get_found_it

        ld de, item_not_present_msg
        call show_msg
        ret

get_found_it:
        ; skip past the name
        inc hl
        inc hl
        ; skip past the short description
        inc hl
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ; skip past the drop-handler
        inc hl
        inc hl
        ; skip past the use-handler
        inc hl
        inc hl
        ; is this item collectable?
        ld a,(hl)
        cp 1
        jr z, get_found_it_take

        ld de, cant_take_that_msg
        call show_msg
        ret

get_found_it_take:
        ; item is now in the players possession
        inc hl
        ld (hl),255

        ; HACK - Was the item being taken the rug?
        ld de, tmp_buffer+1
        ld hl, item_7_name
        ld b, 3 ; strlen("RUG")
        call CompareStringsWithLength
        jp nz, not_taken_rug

        ; show a message telling the user about the trapdoor.
        ld de, rug_taken_msg
        call show_msg

        ; make the trapdoor visible
        ld hl, item_11_name
        call get_item_by_name
        cp 0
        jp z, place_trapdoor

        ld de, failed_find_trapdoor_msg
        call show_msg
        ret

place_trapdoor:
        ; skip past the name
        inc hl
        inc hl
        ; skip past the short description
        inc hl
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ; skip past the drop-function.
        inc hl
        inc hl
        ; skip past the use-function
        inc hl
        inc hl
        ; skip past the "collectable" property
        inc hl

        ; get the current location and add the item there.
        push hl
        ld hl, CURRENT_LOCATION
        ld a,(hl)
        pop hl
        ld (hl), a
        ret
not_taken_rug:
        call inventory_function
        ret







;
; Command-Handler HELP
;
; Show "These commands are available", then the names of each non-hidden
; command.
;
help_function:
        ld de, HELP_MSG
        call show_msg
        ld de,command_table
help_function_again: ; have we run out of commands?
        ld a, (de) ; length of string
        cp 0x00
        ret z
        ld hl, tmp_buffer
        ld b, a    ; B will contain the length
        inc de     ; DE point to the string itself
help_func_loop:  ; copy the command-name to the buffer
        ld a,(de)
        ld (hl),a
        inc hl
        inc de
        djnz help_func_loop
        ld a, 0x0a
        ld (hl),a
        inc hl
        ld a, 0x0d
        ld (hl),a
        inc hl
        ld a, '$'
        ld (hl),a
        push de
        ld a,(de)
        cp 1
        jr z, help_skip_this
        call show_tab
        ld de, tmp_buffer
        ld c, BDOS_OUTPUT_STRING
        call BDOS_ENTRY_POINT
help_skip_this:
        pop de
        inc de
        inc de  ; skip addr1
        inc de  ; skip addr2
        jp  help_function_again



;
; Command-handler INVENTORY
;
inventory_function:
        call player_has_objects         ; is the player carrying:
        cp 0
        jp z, inventory_show_items      ; Yes.  Go show

        ld de,inventory_empty_message   ; Otherwise "Carrying nothing"
        call show_msg
        ret

inventory_show_items:
        ld de,you_carrying_message
        call show_msg

        ;
        ; We know there are items being carried, look for them
        ;
        ld hl, items
        ld b, ITEM_COUNT
inventory_test_item:
        ; hl points to the item
        ; skip past the name
        inc hl
        inc hl
        ; skip past the desc - but save it in DE
        ld e,(hl)
        inc hl
        ld d,(hl)
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ; skip past the drop-handler
        inc hl
        inc hl
        ; skip past the use-function
        inc hl
        inc hl
        ; skip past the "collectable" property
        inc hl
        ld a,(hl)
        cp 0xff ; 0xff means the item is being carried
        jr nz, inv_item_not_carried
          push hl
          push de
          push bc
          push af
          call show_tab
          call show_msg
          call show_newline
          pop af
          pop bc
          pop de
          pop hl
inv_item_not_carried:
        inc hl
        djnz inventory_test_item
        ret



;
; Command-Handler LOOK
;
; Show the current location.  If the seen-flag has not been set then
; show the long description and set the flag.
;
look_function:
        ld de,LOOK_FUNCTION_PREFIX
        call show_msg
        ld hl, CURRENT_LOCATION  ; get current location
        ld a, (hl)
        ld b, a                  ; multiply by the length of each entry
        ld c, LOCATION_ENTRY_LENGTH
        call multiply
        ld de, location_table ; add to base of location table
        add hl,de

look_function_show:
        ; ok we point to the table - show the short version
        ld e, (hl)
        inc hl
        ld d, (hl)
        inc hl
        push hl
        call show_msg
        call show_newline
        call show_newline
        pop hl

        ld e, (hl)  ; get the long-message address in de
        inc hl
        ld d, (hl)
        inc hl

        ; input-buffer starts with L for look?
        ; then always show
        ld bc, input_buffer+2
        ld a, (bc)
        cp 'L'
        jp z,look_show_extended

        ; otherwise if we've seen this room don't show the
        ; extended description or objects.
        ld a, (hl)
        cp 1
        ret z
look_show_extended:
        push hl
        call show_msg
        pop hl

        ld a, 1
        ld (hl), a    ; set the seen-flag


        ; If no items are in this room we can return
        call items_are_present
        cp 0
        ret nz

        ; Show "You see .."
        ld de,you_see_message
        call show_msg

        ;
        ; OK at this point we have looked at the room, and
        ; we want to see the items there.
        ;
        ; Walk over the list of items - and show any which
        ; are present in this room.
        ;
        ld hl, items
        ld b, ITEM_COUNT
look_item_loop:
        ; hl points to the item
        ; skip past the name
        inc hl
        inc hl
        ; skip past the desc - but save it in DE
        ld e,(hl)
        inc hl
        ld d,(hl)
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ; skip past the drop-handler
        inc hl
        inc hl
        ; skip past the use-function
        inc hl
        inc hl
        ; skip past the "collectable" property
        inc hl

        ;
        ; Get the current location
        ;
        push hl
        ld hl, CURRENT_LOCATION
        ld a,(hl)
        pop hl

        ; get the location of this item.
        ld c,(hl)
        cp c
        jr nz, item_not_present

        ; Is the description empty?  Then it is hidden.
        ld a, d
        or e
        jr z, item_not_present

          push hl
          push de
          push bc
          push af
          call show_tab
          call show_msg
          call show_newline
          pop af
          pop bc
          pop de
          pop hl
item_not_present:
        inc hl
        djnz look_item_loop
        ret





; Command-handler MAGIC
;
;
magic_function:
        ld HL,MAGIC_LOCATION
        ld a,(hl)
        inc a
        ld (hl),a

        cp 1
        jr z, magic_one

        cp 2
        jr z, magic_two

        cp 3
        jr z, magic_three

        ; magic four
        ld de, magic_four_msg
        call show_msg

        ; you're dead
        ld hl, PLAYER_DEAD
        inc (hl)
        ret
magic_one:
        ld de, magic_one_msg
        call show_msg
        ret
magic_two:
        ld de, magic_two_msg
        call show_msg
        ret
magic_three:
        ld de, magic_three_msg
        call show_msg
        ret




;
; Command-Handler QUIT
;
; Terminate the game, and show the turn-count.
;
quit_function:
        ld de, QUIT_MSG
        call show_msg
        call show_turn_count
        jp 0x0000




;
; Command-Handler USE
;
; Use the named object, if there is a handler defined for it.
use_function:
        call input_second_term
        cp 0
        jp z, use_object

        ld de, USE_WHAT_MSG
        call show_msg
        ret

use_object:
        ; store object in HL
        call input_second_term

        call get_item_by_name
        cp 0
        jp z, use_found_object

        ld de, item_not_present_msg
        call show_msg
        ret

use_found_object:
        ; skip past the name
        inc hl
        inc hl
        ; skip past the short description
        inc hl
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ; skip past the drop function
        inc hl
        inc hl
        ; Get the use-handler
        ld e, (hl)
        inc hl
        ld d,(hl)
        inc hl

        ; is the use-handler empty?
        ld a, d
        or e
        jr z, use_is_futile

        ; jump to the use-handler
        push de
        pop hl
        call JP_HL
        ret
use_is_futile:
        ld de, use_generic
        call show_msg
        ret




;
; Command-Handler UP
;
; Change location.  Up is possible if you're not on the top-floor.
;
; When in the dark room "UP" moves you up two places.
;
up_function:
        ld hl, CURRENT_LOCATION
        ld a, (hl)
        cp 0
        jr z, no_up                ; can't go up
        cp 1
        jr z, up_on_middle_floor   ; go up
        cp 2
        jr z, up_on_ground_floor   ; go up
        cp 3
        jr z, up_on_basement_floor ; go up
        cp 4
        jr z, up_on_dark_room      ; go up two - to land in ground floor

no_up:
        ld de, no_up_msg
        call show_msg
        ret

up_on_dark_room:
        dec (hl)
            ; fall-through

up_on_middle_floor:
up_on_ground_floor:
up_on_basement_floor:
        dec (hl)
        call look_function
        ret



show_newline:
        ld de, NEWLINE
        jp show_msg

show_tab:
        push af
        push bc
        push de
        push hl
        ld de, TAB
        ld c,BDOS_OUTPUT_STRING
        call BDOS_ENTRY_POINT
        pop hl
        pop de
        pop bc
        pop af
        ret




;********************************************************************
; CUSTOM OBJECT HOOKS
;********************************************************************

;  When you drop the mirror it cracks.
;
;  Remove the "mirror" item from the current location.
;  Add the "mirror-broken" item to the current location.
;
drop_mirror_fn:
        ; find the mirror
        ld hl, item_1_name
        call get_item_by_name

        ; skip past the name
        inc hl
        inc hl
        ; skip past the short description
        inc hl
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ; skip past the drop-function.
        inc hl
        inc hl
        ; skip past the use-function
        inc hl
        inc hl
        ; skip past the "collectable" property
        inc hl

        ; Set the location to be something random
        ld (hl), 0xfe

        ; find the broken-mirror
        ld hl,item_2_name
        call get_item_by_name

        ; skip past the name
        inc hl
        inc hl
        ; skip past the short description
        inc hl
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ; skip past the drop-function.
        inc hl
        inc hl
        ; skip past the use-function
        inc hl
        inc hl
        ; skip past the "collectable" property
        inc hl

        ; Set the location to be the current location
        push hl
        ld hl,CURRENT_LOCATION
        ld a,(hl)
        pop hl
        ld (hl), a

        ; Show the drop message
        ld de, MIRROR_DROP_FUN
        call show_msg
        ret


;  When you USE the TORCH it lights.
;
;  Remove the "torch" item from the current location.
;  Add the "torch-lit" item to the current location.
;
use_torch_fn:
        ; find the torch
        ld hl, item_3_name
        call get_item_by_name

        cp 0
        jp z,use_torch_found_t

        ld de, failed_find_torch_msg
        call show_msg
        ret
use_torch_found_t:
        ; skip past the name
        inc hl
        inc hl
        ; skip past the short description
        inc hl
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ; skip past the drop-function.
        inc hl
        inc hl
        ; skip past the use-function
        inc hl
        inc hl
        ; skip past the "collectable" property
        inc hl

        ; get the current location - to see if we're
        ; setting this in the environment or the users'
        ; inventory
        ld a,(hl)
        push af

        ; Set the location to be something random
        ld (hl), 0xfe

        ; find the lit torch
        ld hl, item_4_name
        call get_item_by_name

        cp 0
        jp z,use_torch_found_t2

        pop af; fixup
        ld de, failed_find_torch_lit_msg
        call show_msg
        ret

use_torch_found_t2:

        ; skip past the name
        inc hl
        inc hl
        ; skip past the short description
        inc hl
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ; skip past the drop-function.
        inc hl
        inc hl
        ; skip past the use-function
        inc hl
        inc hl
        ; skip past the "collectable" property
        inc hl

        ; Set the location to be the same as the
        ; old torch was.
        pop af
        ld (hl),a

        ; Show the message
        ld de, TORCH_ON_MSG
        call show_msg
        ret



;  When you OPEN the TRAPDOOR it opens.
;
;  Remove the "trapdoor" item from the current location.
;  Add the "trapdoor-open" item to the current location.
;
use_trapdoor_fn:
        ; find the trapdoor
        ld hl, item_11_name
        call get_item_by_name

        cp 0
        jp z,use_trapdoor_found_t

        ld de, failed_find_trapdoor_msg
        call show_msg
        ret
use_trapdoor_found_t:
        ; skip past the name
        inc hl
        inc hl
        ; skip past the short description
        inc hl
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ; skip past the drop-function.
        inc hl
        inc hl
        ; skip past the use-function
        inc hl
        inc hl
        ; skip past the "collectable" property
        inc hl

        ; Set the location to be something random
        ld (hl), 0x55

        ; find the trapdoor-open
        ld hl, item_12_name
        call get_item_by_name

        cp 0
        jp z,use_trapdoor_found_t2

        ld de, failed_find_trapdoor_open_msg
        call show_msg
        ret

use_trapdoor_found_t2:

        ; skip past the name
        inc hl
        inc hl
        ; skip past the short description
        inc hl
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ; skip past the drop-function.
        inc hl
        inc hl
        ; skip past the use-function
        inc hl
        inc hl
        ; skip past the "collectable" property
        inc hl

        ; Set the location to be here.
        push hl
        ld hl, CURRENT_LOCATION
        ld a,(hl)
        pop hl
        ld (hl),a

        ; Show the message
        ld de, TRAPDOOR_OPEN_MSG
        call show_msg
        ret




;  When you USE the GENERATOR you win.
;
use_generator_fn:
        ; find the generator
        ld hl, item_0_name
        call get_item_by_name

        cp 0
        jp z,use_generator_found_t

        ld de, failed_find_generator_msg
        call show_msg
        ret

use_generator_found_t:

        ; You can only win if the generator is used on the top-floor
        ld hl, CURRENT_LOCATION
        ld a,(hl)
        cp 0
        jr z, use_generator_won_fn

        ld de, use_gen_location
        call show_msg
        ret
use_generator_won_fn:
        ld hl, PLAYER_WON
        ld (hl),1

        ld de, use_generator_won
        call show_msg
        ret




;********************************************************************
; Data / State Storage
;********************************************************************

TURN_COUNT:
        db 0
CURRENT_LOCATION:
        db 0
PLAYER_DEAD:
        db 0
PLAYER_WON:
        db 0
MAGIC_LOCATION
        db 0


;********************************************************************
; String Area
;********************************************************************

call_911_msg:
call_999_msg:
call_police_msg:
        db 0x0a, 0x0d, "Unfortunately Mayor Goodway's budget mishandling have resulted in a lack of", 0x0a, 0x0d
        db "a functioning police force.", 0x0a, 0x0d
        db 0x0a, 0x0d, "The best you can do is call a bunch of dogs, and their teenaged handler.", 0x0a, 0x0d, "$"

call_unknown_msg:
        db 0x0a, 0x0d, "I'm sorry I don't know who that is.", 0x0a, 0x0d, "$"

call_ryder_msg:
        db 0x0a, 0x0d, "Ryder here!  No pup is too small, no job is too big!", 0x0a, 0x0d
        db 0x0a, 0x0d, "Please leave a message after the beep, and I'll get back to you soon!"
        db 0x0a, 0x0d, 0x0a, 0x0d, "Sorry!", 0x0a, 0x0d, "$"
call_skye_msg:
        db 0x0a, 0x0d, "Skye responds quickly, but over the sound of air roaring down the phone you", 0x0a, 0x0d
        db "cannot hear what she's saying.  She must be a bit up in the air at the moment.", 0x0a, 0x0d, "$"

        db "enjoying a nap.", 0x0a, 0x0d, "$"
call_rubble_msg:
        db 0x0a, 0x0d, "Rubble doesn't answer your phone call, but at this time of day he's probably", 0x0a, 0x0d
        db "enjoying a nap.", 0x0a, 0x0d, "$"
call_me_msg:
        db 0x0a, 0x0d, "Debbie Harry says hello, but then hangs up.", 0x0a, 0x0d, "$"

NEWLINE:
        db 0x0a, 0x0d, "$"
TAB:
        db "     $"
invalid_msg:
        db 0x0a, 0x0d, "I'm sorry, I did not understnad that.", 0x0a, 0x0d, "$"
BAD_LANGUAGE_MSG:
        db 0x0a, 0x0d, "What language!", 0x0a, 0x0d, "$"
NO_PHONE_HERE:
        db 0x0a, 0x0d, "You can't see a telephone to use here!", 0x0a, 0x0d, "$"
magic_one_msg:
        db 0x0a, 0x0d, "Magic happens.",  0x0a, 0x0d, "$"
magic_two_msg:
        db 0x0a, 0x0d, "Magic intensifies.",  0x0a, 0x0d, "$"
magic_three_msg:
        db 0x0a, 0x0d, "The sensation of magic screaming through your veins gives you a heady rush.",  0x0a, 0x0d
        db "This can't be good for you, maybe stop now?", 0x0a, 0x0d, "$"
magic_four_msg:
        db 0x0a, 0x0d , "You couldn't draw the line, could you?", 0x0a, 0x0d, 0x0a, 0x0d
        db "The magic flooding your body is too powerful, and you're finding it impossible", 0x0a, 0x0d
        db "to breath.  With a wail of frustration you topple backwards, clutching", 0x0a, 0x0d
        db "at your chest.", 0x0a, 0x0d, 0x0a, 0x0d
        db "You're dying, soon the end will come.", 0x0a, 0x0d, 0x0a, 0x0d, "$"

CALL_WHO_MSG:
        db 0x0a, 0x0d, "Call who?", 0x0a, 0x0d, "$"
no_up_msg:
        db 0x0a, 0x0d, "You can't go up from here.", 0x0a, 0x0d, "$"
no_down_msg:
        db 0x0a, 0x0d, "You can't go down from here.", 0x0a, 0x0d, "$"
rug_taken_msg:
        db 0x0a, 0x0d, "As you take the rug you see it covered a trapdoor.", 0x0a, 0x0d, "$"
failed_find_torch_msg:
        db 0x0a, 0x0d, "BUG:Failed to find torch.", 0x0a, 0x0d, "$"
failed_find_trapdoor_msg:
        db 0x0a, 0x0d, "BUG:Failed to find trapdoor", 0x0a, 0x0d, "$"
failed_find_trapdoor_open_msg:
        db 0x0a, 0x0d, "BUG:Failed to find open trapdoor", 0x0a, 0x0d, "$"
TRAPDOOR_OPEN_MSG:
        db 0x0a, 0x0d, "The trapdoor opens, showing a murky set of steps leading downwards into shadow.", 0x0a, 0x0d, "$"
failed_find_torch_lit_msg:
        db 0x0a, 0x0d, "BUG:Failed to find the lit torch.", 0x0a, 0x0d, "$"
failed_find_generator_msg:
        db 0x0a, 0x0d, "BUG:Failed to find the generator.", 0x0a, 0x0d, "$"
CLS_MSG:
        db 27, "[2J"            ; "clear"
        db 27, "[H"             ; "home"
        db "$"
use_gen_location:
        db 0x0a, 0x0d, "You cannot see anywhere to connect the generator to."
        db 0x0a, 0x0d, "$"
use_generator_won:
        db 0x0a, 0x0d, "You connect the generator to the console, and turn it on", 0x0a, 0x0d
        db "with a steady thrum the generator begins to provide power.", 0x0a, 0x0d
        db 0x0a, 0x0d
        db "Success!  The main-light turns on.", 0x0a, 0x0d,0x0a, 0x0d
        db "The boat sees the light, and begins to execute a sharp turn to port,", 0x0a, 0x0d
        db "it looks like it will make it.", 0x0a, 0x0d
        db 0x0a, 0x0d
        db "Congratulations!", 0x0a, 0x0d
        db "$"
QUIT_MSG:
        db 0x0a, 0x0d, "You said 'QUIT' so we terminate!", 0x0a, 0x0d, "$"
HELP_MSG:
        db 0x0a, 0x0d, "The following commands are available:", 0x0a, 0x0d, "$"
EXAMINE_WHAT_MSG:
        db 0x0a, 0x0d, "Examine what?", 0x0a, 0x0d, "$"
GET_WHAT_MSG:
        db 0x0a, 0x0d, "Take what?", 0x0a, 0x0d, "$"
DROP_WHAT_MSG:
        db 0x0a, 0x0d, "Drop what?", 0x0a, 0x0d, "$"
USE_WHAT_MSG:
        db 0x0a, 0x0d, "Use what?", 0x0a, 0x0d, "$"
cant_take_that_msg:
        db 0x0a, 0x0d, "You can't take that.", 0x0a, 0x0d, "$"
you_drop_it:
        db 0x0a, 0x0d, "You drop it", 0x0a, 0x0d, "$"
prompt_message:
        db 0x0a, 0x0d,">$"
inventory_empty_message:
        db 0x0a, 0x0d, "You are carrying nothing.", 0x0a, 0x0d, "$"
you_carrying_message:
        db 0x0a, 0x0d, "You are carrying:", 0x0a, 0x0d, "$"
you_see_message:
        db 0x0a, 0x0d, "You see:", 0x0a, 0x0d, "$"
use_generic:
        db 0x0a, 0x0d, "Nothing seems to happen.", 0x0a, 0x0d, "$"
item_not_present_msg:
        db  0x0a, 0x0d, "I can't see that here!", 0x0a, 0x0d, "$"
not_carrying_item_msg:
        db 0x0a, 0x0d, "You're not carrying that!", 0x0a, 0x0d, "$"
MIRROR_DROP_FUN:
        db 0x0a, 0x0d, "You drop the mirror, which cracks and breaks.", 0x0a, 0x0d, "$"
TORCH_ON_MSG:
        db 0x0a, 0x0d, "You turn on the torch.", 0x0a, 0x0d, "$"
usage_message:
        db "Lighthouse of doom!", 0x0a, 0x0d
        db "===================", 0x0a, 0x0d, 0x0a, 0x0d
        db "This is an original text-based adventure game written for CP/M."
        db 0x0a, 0x0d
        db 0x0a, 0x0d
        db "Written by Steve Kemp in 2021, with source available on github:"
        db 0x0a, 0x0d
        db 0x0a, 0x0d
        db "  https://github.com/skx/lighthouse-of-doom"
        db 0x0a, 0x0d
        db 0x0a, 0x0d
        db "Bug reports are most welcome, as are puzzle-suggestions and other feedback."
        db 0x0a, 0x0d
        db 0x0a, 0x0d
        db "Any references to the Paw Patrol are entirely deliberate."
        db 0x0a, 0x0d
        db 0x0a, 0x0d
        db 0x0a, 0x0d
        db 0x0a, 0x0d
        db "Press any key to start."
        db 0x0a, 0x0d, "$"

PLAYER_DEAD_MESSAGE:
        db 0x0a, 0x0d, "Unfortunately you took too long to fix the broken light."
        db 0x0a, 0x0d
        db 0x0a, 0x0d, "The ship ploughs into the base of your lighthouse, causing it to collapse around"
        db 0x0a, 0x0d, "you."
        db 0x0a, 0x0d
        db 0x0a, 0x0d, "You're buried and helpless, and as the darkness consumes you the sounds of the"
        db 0x0a, 0x0d, "sailors thrashing in the water reach you, from a distance."
        db 0x0a, 0x0d
        db 0x0a, 0x0d, "Let us hope some of them can swim to shore.."

        db 0x0a, 0x0d
        db 0x0a, 0x0d
        db "Game over - you're dead."
        db 0x0a, 0x0d,"$"
PLAYER_WON_MESSAGE:
        db 0x0a, 0x0d
        db "You won!"
        db 0x0a, 0x0d,"$"
PLAYER_TURN_COUNT:
        db "You've played $"
PLAYER_TURN_COUNT_END:
        db " turns."
        db 0x0a, 0x0d,"$"
LOOK_FUNCTION_PREFIX:
        db 0x0a, 0x0d, "You are in $"

;
; Location text
;
location_0_short:
        db "the top floor of the lighthouse.$"
location_0_long:
        db "The lighthouse has a spiral staircase which runs from top to bottom.", 0x0a, 0x0d
        db "Through the window you can see the lights of an approach ship, and", 0x0a, 0x0d
        db "you know that it will crash upon the rocks if you can't signal it away.", 0x0a, 0x0d
        db "Too bad the lighthouse light doesn't seem to be working, it looks like", 0x0a, 0x0d
        db "there's a problem with the power.", 0x0a, 0x0d
        db "$"

location_1_short:
        db "the middle floor of the lighthouse.$"
location_1_long:
        db "The middle floor of the lighthouse seems to be a relaxation-room,", 0x0a, 0x0d
        db "you see some comfy chairs, a work-desk, as well as various odds and", 0x0a, 0x0d
        db "ends.", 0x0a, 0x0d, 0x0a, 0x0d
        db "An impressive painting hangs over the desk, and a dog sleeps in a basket", 0x0a, 0x0d
        db "to the side of it.", 0x0a, 0x0d
        db "$"

location_2_short:
        db "the ground floor of the lighthouse.$"
location_2_long:
        db "The ground floor seems very crowded, with most of the room", 0x0a, 0x0d
        db "taken up by a coat-rack, boots, and similar things.", 0x0a, 0x0d
        db "$"


location_3_short:
        db "the lighthouse basement.$"
location_3_long:
        db "This seems to be a graveyard for discarded machinery, and", 0x0a, 0x0d
        db "other random junk.", 0x0a, 0x0d
        db "$"

location_4_short:
        db "a dark place.$"
location_4_long:
        db "You cannot see anything, but you can certainly hear a snarling.", 0x0a, 0x0d
        db "There is also a strong smell, a feral smell, could it be that this", 0x0a, 0x0d
        db "is the haunt of a grue?", 0x0a, 0x0d
        db "$"


;
; Item text
;
item_0_name: db "GENERATOR"
item_0_desc: db "A small generator.$"
item_0_long: db "This is a diesel-power generator, which seems to be full of fuel, and ready to go."
             db "$"

item_1_name:  db "MIRROR"
item_1_desc:  db "A small mirror.$"
item_1_long:  db "The mirror doesn't seem to be anything special.", 0x0a, 0x0d
              db "But your reflection?  It looks fabulous.", 0x0a, 0x0d
              db "$"

item_2_name:  db "MIRROR-BROKEN"
item_2_desc:  db "A small mirror, which is cracked and broken.$"
item_2_long:  db "The mirror was once small and delicate.", 0x0a, 0x0d
              db "But now it shows a distored reflection of yourself,", 0x0a, 0x0d
              db "which is oddly unsettling.", 0x0a, 0x0d
              db "$"

item_3_name:  db "TORCH"
item_3_desc:  db "A small torch.$"
item_3_long:  db "The torch doesn't seem to be anything special,", 0x0a, 0x0d
              db "but you do notice that it contains batteries and can be turned on easily.", 0x0a, 0x0d
              db "$"

item_4_name:  db "TORCH-LIT"
item_4_desc:  db "A small torch, which is turned on.$"
item_4_long:  db "The torch doesn't seem to be anything special.", 0x0a, 0x0d
              db "$"

item_5_name:  db "DOG"
item_5_long:  db "The dog seems to be sleeping quite deeply.  As you examine him ", 0x0a, 0x0d
              db "he mutters something about 'Apollo the Super-Pup' in his sleep,", 0x0a, 0x0d
              db "before settling back into silence.", 0x0a, 0x0d
              db "$"

item_6_name:  db "PAINTING"
item_6_long:  db "The painting shows a teenager with spiky hair, surrounded by a group of dogs.$"


item_7_name: db "RUG"
item_7_desc: db "A small rug.$"
item_7_long: db "The rug is made of coarse wool, roughly woven, but there's nothing remarkable", 0x0a, 0x0d
             db "about it.", 0x0a, 0x0d, "$"

item_8_name: db "BOOK"
item_8_desc: db "A small black book.$"
item_8_long: db "The little black book seems to contain names and phone numbers:", 0x0a, 0x0d, 0x0a, 0x0d
             db "\t   Police    - 999", 0x0a, 0x0d
             db "\tAmbulance    - 999", 0x0a, 0x0d
             db "\tFire Service - 999", 0x0a, 0x0d
             db "\tPaw Patrol   - 999", 0x0a, 0x0d
             db 0x0a, 0x0d
             db "Too bad there are no instructions on powering the main light.", 0x0a, 0x0d, "$"

item_9_name: db "DESK"
item_9_long: db "The desk is made of solid wood, unlike everything else in the room.", 0x0a, 0x0d, "$"

item_10_name: db "TELEPHONE"
item_10_desc: db "A telephone, wired to the wall.$"
item_10_long: db "The telephone is an average telephone, which looks like it was made in the 80s.", 0x0a, 0x0d, "$"

item_11_name: db "TRAPDOOR"
item_11_desc: db "A closed trapdoor.$"
item_11_long: db "You cannot see anything special about the trapdoor.", 0x0a, 0x0d
              db "Perhaps you should open it to explore further?", 0x0a, 0x0d, "$"

item_12_name: db "TRAPDOOR-OPEN"
item_12_desc: db "An open trapdoor.$"
item_12_long: db "You cannot see anything special about the trapdoor.", 0x0a, 0x0d, "$"


;
; People text
;



;********************************************************************
; Table Area
;********************************************************************


;
; Our command-table contains the commands we accept, a pointer to their
; handlers, and a "hidden" flag.
;
; The HELP command will show all non-hidden commands.
;
; NOTE: There is no help-text for the commands
;
command_table:
        DEFB 3, 'CLS', 1
          DEFW cls_function
        DEFB 4, 'DOWN', 0
          DEFW down_function
        DEFB 4, 'DROP', 0
          DEFW drop_function
        DEFB 7, 'EXAMINE', 0
          DEFW examine_function
        DEFB 3, 'GET', 0
          DEFW get_function
        DEFB 4, 'HELP', 0
          DEFW help_function
        DEFB 4, 'LOOK', 0
          DEFW look_function
        DEFB 9, 'INVENTORY', 0
          DEFW inventory_function
        DEFB 4, 'QUIT', 0
          DEFW quit_function
        DEFB 5, 'TURNS', 0
          DEFW show_turn_count
        DEFB 2, 'UP', 0
          DEFW up_function
        DEFB 3, 'USE', 0
          DEFW use_function
        ;; synonyms
        DEFB 4, 'TAKE', 1
          DEFW get_function
        DEFB 6, 'PICKUP', 1
          DEFW get_function
        DEFB 4, 'OPEN', 1
          DEFW use_function
        DEFB 4, 'READ', 1
          DEFW use_function
        ;; easter-eges
        DEFB 4, 'CALL', 1
          DEFW call_function
        DEFB 4, 'DIAL', 1
          DEFW call_function
        DEFB 4, 'FUCK', 1
          DEFW bad_language_function
        DEFB 5, 'PHONE', 1
          DEFW call_function
        DEFB 4, 'SHIT', 1
          DEFW bad_language_function
        DEFB 5, 'XYZZY', 1
          DEFW magic_function
        ;; abbreviations
        DEFB 1, 'L', 1
          DEFW look_function
        DEFB 3, 'INV', 1
          DEFW inventory_function
        DEFB 1, 'I', 1
          DEFW inventory_function
        DEFB 1, 'U', 1
          DEFW up_function
        DEFB 1, 'D', 1
          DEFW down_function
        DEFB 0


;
; People table
;
; Similar to the command-table, each entry is:
;
;  LENGTH "NAME HERE" Ptr-To-Response
;
people_table:
        DEFB 3, '911'
             DEFW call_911_msg
        DEFB 3, '999'
             DEFW call_999_msg
        DEFB 6, 'POLICE'
             DEFW call_police_msg
        DEFB 5, 'RYDER'
             DEFW call_ryder_msg
        DEFB 5, 'RIDER'
             DEFW call_ryder_msg
        DEFB 10, 'PAW PATROL'
             DEFW call_ryder_msg
        DEFB 14, 'THE PAW PATROL'
             DEFW call_ryder_msg
        DEFB 4, 'SKYE'
             DEFW call_skye_msg
        DEFB 6, 'RUBBLE'
             DEFW call_rubble_msg
        DEFB 2, 'ME'
             DEFW call_me_msg
        DEFB 0


;
; Location table
;
; Each location contains a pointer to a short-description, a pointer to
; a long description, and a seen-flag.
;
location_table:
        DEFW location_0_short
        DEFW location_0_long
        DB 0 ; seen-flag
location_first:
        DEFW location_1_short
        DEFW location_1_long
        DB 0 ; seen-flag

        DEFW location_2_short
        DEFW location_2_long
        DB 0 ; seen-flag

        DEFW location_3_short
        DEFW location_3_long
        DB 0 ; seen-flag

        DEFW location_4_short
        DEFW location_4_long
        DB 0 ; seen-flag

LOCATION_ENTRY_LENGTH: EQU location_first - location_table


;
; Item table
;
; Each item contains:
;
;   1. A pointer to the (internal) name.
;   2. A pointer to a short description - this will be empty for "hidden" items.
;   3. A pointer to a long description.
;   4. A pointer to a drop-function.
;   5. A pointer to a use-function.
;   6. A byte to specify whether this can be taken.
;   7. A byte to contain the location of the object.
;       0xff == player is carrying it.
;       0xfe == can be found.
;
items:
        DEFW item_0_name  ; generator
        DEFW item_0_desc
        DEFW item_0_long
        DEFB 0,0          ; No drop function
        DEFW use_generator_fn ; handler
        DEFB 1            ; this item can be picked up
        DEFB 0x03         ; basement

item_first:
        DEFW item_1_name  ; mirror
        DEFW item_1_desc
        DEFW item_1_long
        DEFW drop_mirror_fn  ; custom drop function
        DEFB 0,0          ; No use function
        DEFB 1            ; this item can be picked up
        DEFB 0x01         ; middle-floor

        DEFW item_2_name  ; mirror-broken
        DEFW item_2_desc
        DEFW item_2_long
        DEFB 0,0          ; No drop function
        DEFB 0,0          ; No use function
        DEFB 1            ; this item can be picked up
        DEFB 0xFe         ; not visible anywhere

        DEFW item_3_name  ; torch
        DEFW item_3_desc
        DEFW item_3_long
        DEFB 0,0          ; No drop function
        DEFW use_torch_fn ; USE TORCH
        DEFB 1            ; this item can be picked up
        DEFB 0x00         ; top-floor

        DEFW item_4_name  ; torch-lit
        DEFW item_4_desc
        DEFW item_4_long
        DEFB 0,0          ; No drop function
        DEFB 0,0          ; No use function
        DEFB 1            ; this item can be picked up
        DEFB 0xFE         ; not visible anywhere

        DEFW item_5_name  ; dog
        DEFB 0,0          ; NO DESCRIPTION - hidden item
        DEFW item_5_long
        DEFB 0,0          ; No drop function
        DEFB 0,0          ; No use function
        DEFB 0            ; this item cannot be picked up
        DEFB 0x01         ; middle-floor

        DEFW item_6_name  ; painting
        DEFB 0,0          ; NO DESCRIPTION - hidden item
        DEFW item_6_long
        DEFB 0,0          ; No drop function
        DEFB 0,0          ; No use function
        DEFB 0            ; this item cannot be picked up
        DEFB 0x01         ; middle-floor

        DEFW item_7_name  ; rug
        DEFW item_7_desc
        DEFW item_7_long
        DEFB 0,0          ; No drop function
        DEFB 0,0          ; No use function
        DEFB 1            ; this item can be picked up
        DEFB 0x02         ; ground-floor

        DEFW item_8_name  ; book
        DEFW item_8_desc
        DEFW item_8_long
        DEFB 0,0          ; No drop function
        DEFB 0,0          ; No use function
        DEFB 1            ; this item can be picked up
        DEFB 0x01         ; middle-floor

        DEFW item_9_name  ; desk
        DEFB 0,0          ; NO DESCRIPTION - hidden item
        DEFW item_9_long
        DEFB 0,0          ; No drop function
        DEFB 0,0          ; No use function
        DEFB 0            ; this item cannot be picked up
        DEFB 0x01         ; middle-floor

        DEFW item_10_name ; telephone
        DEFB 0,0          ; NO DESCRIPTION - hidden item
        DEFW item_10_long
        DEFB 0,0          ; No drop function
        DEFB 0,0          ; No use function
        DEFB 0            ; this item cannot be picked up
        DEFB 0x01         ; middle-floor

        DEFW item_11_name ; trapdoor
        DEFW item_11_desc
        DEFW item_11_long
        DEFB 0,0          ; No drop function
        DEFW use_trapdoor_fn ; open function
        DEFB 0            ; this item cannot be picked up
        DEFB 0xFE         ; hidden until the rug is moved

        DEFW item_12_name ; trapdoor-open
        DEFW item_12_desc
        DEFW item_12_long
        DEFB 0,0          ; No drop function
        DEFB 0,0          ; No use function
        DEFB 0            ; this item cannot be picked up
        DEFB 0xFE         ; hidden until the trapdoor is opened.

item_last:

; length of an entry in the item table.
ITEM_ENTRY_LENGTH: EQU item_first - items
ITEM_COUNT: EQU ( item_last - items ) / ITEM_ENTRY_LENGTH





;********************************************************************
; Buffer Area
;********************************************************************

;
; This is the buffer which is used for reading a line of text from the
; CP/M BIOS.
;
; The way this works is you pass the address of a region of memory, the
; first byte is the length of the buffer, the second byte will be populated
; by the amount of text which was read.
;
; After that goes the input itself, obviously.
input_buffer:
        db 100  ; size of our input-buffer
        db 0x00 ; Count of characters returned.



;
; A temporary buffer, available to all handlers.
;
; This is placed after the input-buffer above, and is defined as being 50
; bytes long.  It is used for finding the argument to a handler.
;
; For example:
;
;   CALL RYDER
;
; The CALL handler will be invoked, and the object of the call, "RYDER" will
; be copied into this buffer for table-lookup.
;
tmp_buffer: EQU input_buffer + 255
TMP_BUFFER_LEN: EQU 50


;
; Our source code ends here.
;
; We use this label to calculate how many bytes to decrypt when we
; launch - if that support is enabled.
;
end_of_source:
