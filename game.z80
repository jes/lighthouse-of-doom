;
; LIGHTHOUSE OF DOOM!!!
;
; Steve Kemp
; -
; https://steve.kemp.fi/
;
; https://github.com/skx/lighthouse-of-doom
;


;
; This is a work-in-progress porting the game to Z80 assembly, such
; that it will run under CP/M 2.x
;
; The current state is minimal:
;
;   1.  We prompt for input, continuously
;   2.  If the input matches a known word we execute it.
;   3.  Otherwise we echo the input
;   4.  GOTO 1.
;
; We have declared a complete list of command-handlers, but most of them
; are not implemented.
;
; We've defined our location-map but the movement commands are broken,
; because we don't sanity-check and while we can manually place items
; in our map and inventory there are no working commands for operating
; with/upon them.
;

;
; Deviations from the C-code
;   Rather than having slots in the locations, and the player, for
;  storing objects we instead make the location a property of each
;  item.
;
;   An item will have location "FF" if the player is carrying it,
;  otherwise the location will be the room it is stored within.
;
;
;
; Deficiencies
;
;   HELP command doesn't show description next to command.
;
;

; BIOS entry-point
BDOS_ENTRY_POINT:    EQU 5

; BIOS functions we call
BDOS_CHARACTER_READ:  EQU 0x01
BDOS_OUTPUT_STRING:  EQU 0x09
BDOS_READ_INPUT:     EQU 0x0A
BDOS_OUTPUT_SINGLE_CHARACTER: EQU 0x02




        ORG 100h

        ; Clear the screen
        call cls_function

        ; Opening banner
        ld de, usage_message
        ld c, BDOS_OUTPUT_STRING
        call BDOS_ENTRY_POINT

        ; Pause for input here.
        ld c,BDOS_CHARACTER_READ
        call BDOS_ENTRY_POINT
        call cls_function

        ; Show the starting-location.
        call show_newline
        ld hl, input_buffer+2
        ld a, 'L'
        ld (hl), a
        call look_function

        ; Game Loop
        ;
        ;  1.  Show prompt.
        ;  2.  Read a line of input.
        ;  3.  Upper-case the input.
        ;  4.  Look for a handler, if found call it
        ;  5.    Otherwise echo the input
        ;  6.  Goto 1.
game_loop:

        ; 0. Is the player dead?  Did the player win?
        ld hl, PLAYER_DEAD
        ld a, (hl)
        cp 1
        jp nz,not_dead

        ld de, PLAYER_DEAD_MESSAGE
        call show_msg
        call show_turn_count
        jp 0x0000

not_dead:
        ld hl, PLAYER_WON
        ld a, (hl)
        cp 1
        jp nz, not_won

        ld de, PLAYER_WON_MESSAGE
        call show_msg
        call show_turn_count
        jp 0x0000

not_won:
        ; 1. show the prompt
        ld de, prompt_message
        ld c, BDOS_OUTPUT_STRING
        call BDOS_ENTRY_POINT

        ; 2. read the line of input
        ld b, 0xff
        ld hl,input_buffer+2
        ld a,0
erase_input_buffer:
        ld (hl),a
        inc hl
        djnz erase_input_buffer

        ld de, input_buffer
        ld c, BDOS_READ_INPUT
        call BDOS_ENTRY_POINT

        ; (debug) show the input-text
        ld hl,DEBUG_STORE
        ld a,(hl)
        cp 0
        jp z, continue1

        ld de,DEBUG_YOU_ENTERED_MSG
        call show_msg
        call show_input_buffer
        call show_newline
continue1:
        ; 3. upper-case the input
        ld hl, input_buffer+1
        ld b,(hl)
        inc hl
game_loop_uc_loop:
        ld a, (hl)
        cp 'a'
        jr c, game_loop_uc_nc
        cp 'z'
        jr nc, game_loop_uc_nc
        sub 32
game_loop_uc_nc:
        ld (hl),a
        inc hl
        djnz game_loop_uc_loop

        ; (debug) show the result of the upper-casing
        ld hl,DEBUG_STORE
        ld a,(hl)
        cp 0
        jp z, continue2

        ld de,DEBUG_AFTER_CASE_CHANGE
        call show_msg
        call show_input_buffer
        call show_newline

continue2:
        ;  4.  Look for a handler, if found call it
        ld hl, input_buffer+2
        call find_command
        cp 255
        jp z, no_handler

        ; Call the handler
        call JP_HL

        ; Valid command - increase turn count
        ld hl, TURN_COUNT
        inc (hl)

        ; And restart the command-loop
        jp game_loop


no_handler:
        ; Invalid command, but this is still a turn
        ld hl, TURN_COUNT
        inc (hl)

        ;  5.  Goto 1
        jp game_loop              ; restart



;
; Called only as part of the debugging routine
;
show_input_buffer:
        ld hl, input_buffer+1
        ld b,(hl)
        inc hl
show_char_loop:
        ld e, (hl)
        push bc
        push hl
        ld c, BDOS_OUTPUT_SINGLE_CHARACTER
        call BDOS_ENTRY_POINT
        pop hl
        pop bc
        inc hl
        djnz show_char_loop
        ret


; This will be a major part of our code so it is perhaps a little more
; verbose than it wants to be.
;
; Find the entry in the command-table.  If we find it return the address
; of the routine to call in `HL`.
;
; On entry `HL` should contain the pointer to the input buffer to look
; for.
;
; On exit A contains 0 on success, with HL pointing to the handler to invoke,
; or A contains 255 on failure.
find_command:
        ld de,command_table

        ; get the length of the entry in the command table
        ;
        ; Entries are arranged like so:
        ;   $LENGTH "ASCII" $HIDDEN ADDR1 ADDR2
        ;
        ; Where $LENGTH is the length of the ASCII command-name.
        ;
        ; So:
        ;
        ;   4, "QUIT", 0, quit_fn_ptr
        ;   3, "CLS",  1, cls_fn_ptr
        ;   0,
        ;
find_command_again:
        push de
        ld a, (de) ; length of string
        cp 0x00
        jr nz, cont
        pop de
        ld a,255
        ret
cont:
        ld b, a    ; B will contain the length
        inc de     ; DE point to the string itself

        push hl
        call CompareStringsWithLength
        jp z,find_command_found
        pop hl

        ; ok we didn't find
        pop de
        ld a, (de)
        inc de
        ld b,a
find_command_skip:
        inc de
        djnz find_command_skip
        inc de ; hidden-flag
        inc de ; addr1
        inc de ; addr2
        ; next entry - might be zero-terminated
        jp  find_command_again

find_command_found:
        pop hl
        pop de ; points to the length before the entry

        ld a, (de)
        inc de
        ld b,a
find_command_skip2:
        inc de
        djnz find_command_skip2
        inc de ; skip the hidden-flag
        ld a, (de)
        ld l,a
        inc de
        ld a, (de)
        ld h,a
        ld a,0
        ret


; compare strings stored in HL + DE for equality.  Length is stored in B
; Returns NZ if they're not equal.
CompareStringsWithLength:
    ld a,(de)
    cp (hl)
    ret nz     ;nz means they are not equal
    inc hl
    inc de
    djnz CompareStringsWithLength
    ld a,0
    ret


;
; Helper function, used by our dispatch function.
;
JP_HL:
        ld bc, ret_obj
        push bc
	push hl
ret_obj:
        ret


;
; Helper function.  Are items present in this room?
;
; Return "A == 0" if so.
;
; Return "A == FF" if not
;
items_are_present:
        ld hl, CURRENT_LOCATION
        ld a,(hl)

        ld hl, items
        ld b, ITEM_COUNT
look_item_loop_test:
        ; hl points to the item
        ; skip past the name
        inc hl
        inc hl
        ; skip past the description
        inc hl
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ld c,(hl)
        cp c
        jr nz, item_not_present_loop
           xor a
           ret
item_not_present_loop:
        inc hl
        djnz look_item_loop_test
        ld a, 0xff
        ret


;
; Helper function.  Is the player carrying something?
;
; Return "A == 0" if so.
;
; Return "A == FF" if not
;
player_has_objects:
        ld hl, items
        ld b, ITEM_COUNT
player_has_objects_loop:
        ; hl points to the item
        ; skip past the name
        inc hl
        inc hl
        ; skip past the description
        inc hl
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ld a,(hl)
        cp 255
        jr nz, player_not_carrying_loop
           xor a
           ret
player_not_carrying_loop:
        inc hl
        djnz player_has_objects_loop
        ld a, 0xff
        ret



; Helper function - get length of string pointed to by HL
;
; Return length in b
;
strlen:
        push hl
        push af
        xor b
strlen_loop:
        ld a,(hl)
        cp 0
        jp z,strlen_end
        inc hl
        inc b
        jp strlen_loop
strlen_end:
        pop af
        pop hl
        ret

;
;
; Helper function - get pointer to second command-line word
;
; e.g. The user enters "GET TORCH", "EXAMINE BOOK", etc, we want to
; get the start of second-word "TORCH", "BOOK"
;
input_second_term:
        ld hl, input_buffer+2

        ; start be incrementing the pointer until we find a space
input_second_term_loop1:
        ld a,(hl)
        cp 0
        jp z,input_second_term_end
        cp ' '
        jp z, input_second_term_found_space
        inc hl
        jp input_second_term_loop1

        ; At this point HL points to " "
input_second_term_found_space:
        ld a,(hl)
        cp 0
        jp z,input_second_term_end
        cp ' '
        jp nz, input_second_term_found_word
        inc hl
        jp input_second_term_found_space

input_second_term_found_word:
        ; HL points to the word
        ld a,0
        ret

input_second_term_end:
        ld a, 0xff
        ret

; INPUT: THE VALUES IN REGISTER B EN C
; OUTPUT: HL = B * C
; CHANGES: AF,DE,HL,B
;
multiply:
	LD HL,0
	LD A,B
	OR A
	RET Z
	LD D,0
	LD E,C
LOOP:	ADD HL,DE
	DJNZ LOOP
	RET

;
; Output numbers
;
DispHL:
	ld	bc,-10000
	call	Num1
	ld	bc,-1000
	call	Num1
	ld	bc,-100
	call	Num1
	ld	c,-10
	call	Num1
	ld	c,-1
Num1:	ld	a,'0'-1
Num2:	inc	a
	add	hl,bc
	jr	c,Num2
	sbc	hl,bc
        push hl
        push de
        push bc
        push af

        ld c, BDOS_OUTPUT_SINGLE_CHARACTER
        ld e, a
        call BDOS_ENTRY_POINT

        pop af
        pop bc
        pop de
        pop hl
	ret

show_a_register:
        ld h,0
	ld l,a
	jp DispHL


;
; Show the number of turns a user has played
;
show_turn_count:
        call show_newline
        ld de, PLAYER_TURN_COUNT
        call show_msg
        ld hl, TURN_COUNT
        ld a, (hl)
        inc a
        call show_a_register
        ld de, PLAYER_TURN_COUNT_END
        call show_msg
        ret




;********************************************************************
; Command Handlers
;********************************************************************


;
; Command-Handler CLS
;
;  Clear the screen
cls_function:
        ld de, CLS_MSG
        jp show_msg


;
; Command-Handler DEBUG
;
debug_function:
        ld hl,DEBUG_STORE
        ld a,(hl)
        cp 0
        jr z, debug_turn_on
        ld a,0
        ld (hl),a
        ld de, debug_off_msg
        call show_msg
        ret

debug_turn_on:
        ld a,1
        ld (hl),a
        ld de, debug_on_msg
        call show_msg
        ret

;
; Command-Handler DOWN
;
; Change location - TODO fix this
;
down_function:
        ld hl, CURRENT_LOCATION
        inc (hl)
        call look_function
        ret

;
; Command-Handler EXAMINE
;
; Examine either:
;
;   1.  An item in the current location.
;
;   2.  An item in the users' inventory.
;
; Examination means:
;
;   1.  Identify the object from the input-buffer
;   2.  Check if the object exists, and if so
;   3.  Show the extended-description
;
examine_function:
        call input_second_term
        cp 0
        jp z, examine_object

        ld DE, EXAMINE_WHAT_MSG
        call show_msg
        ret

examine_object:
        call show_newline

        ; erase our temporary buffer
        ld b,TMP_BUFFER_LEN
        ld hl,tmp_buffer
ex_erase:
        ld (hl),0
        inc hl
        djnz ex_erase

        ; OK we shall copy the second-term to the temporary buffer
        call input_second_term
        ld de,tmp_buffer+1
        ld b,0
ex_copy_loop:
        ld a,(hl)
        cp 0
        jr z, copy_finished
        ld (de),a
        inc de
        inc hl
        inc b
        jr ex_copy_loop

copy_finished:
        ld hl, tmp_buffer
        ld (hl),b

        ld hl, items
        ld b, ITEM_COUNT
examine_objects_loop:
        ; hl points to the item
        ; skip past the name - but save it in DE
        ld e,(hl)
        inc hl
        ld d,(hl)
        inc hl
        ; skip past the desc
        inc hl
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ; is this object carried?
        ld a,(hl)
        cp 0xff ; 0xff means the item is being carried
        jr z, examine_object_present
        push hl
        ld hl, CURRENT_LOCATION
        ld c,(hl)
        pop hl
        cp c
        jr z, examine_object_present
examine_not_present:
        inc hl
        djnz examine_objects_loop
        ret

examine_object_present:
        push hl ; preserve our entry into the item
        push bc ; preserve b for our loop

        ld hl, tmp_buffer ; Get the length from our buffer
        ld b, (hl)
        inc hl            ; Now DE points to the input

        call CompareStringsWithLength
        jp z, examine_do_it

        pop bc
        pop hl
        jr examine_not_present

examine_do_it:
        pop bc
        pop hl

        push hl
        push bc

        dec hl
        dec hl

        ld e,(hl)
        inc hl
        ld d,(hl)
        inc hl

        call show_msg
        pop bc
        pop hl
        jr examine_not_present

;
; Command-Handler QUIT
;
; Terminate the game, and show the turn-count.
;
quit_function:
        ld de, QUIT_MSG
        call show_msg
        call show_turn_count

        jp 0x0000

;
; Command-Handler HELP
;
; Show "These commands are available", then the names of each non-hidden
; command.
;
help_function:
        ld de, HELP_MSG
        call show_msg
        ld de,command_table
help_function_again: ; have we run out of commands?
        ld a, (de) ; length of string
        cp 0x00
        ret z
        ld hl, tmp_buffer
        ld b, a    ; B will contain the length
        inc de     ; DE point to the string itself
help_func_loop:  ; copy the command-name to the buffer
        ld a,(de)
        ld (hl),a
        inc hl
        inc de
        djnz help_func_loop
        ld a, 0x0a
        ld (hl),a
        inc hl
        ld a, 0x0d
        ld (hl),a
        ld a, '$'
        ld (hl),a
        push de
        ld a,(de)
        cp 1
        jr z, help_skip_this
        ld de, tmp_buffer
        ld c, BDOS_OUTPUT_STRING
        call BDOS_ENTRY_POINT
help_skip_this:
        pop de
        inc de
        inc de  ; skip addr1
        inc de  ; skip addr2
        jp  help_function_again



;
; Command-handler INVENTORY
;
inventory_function:
        call player_has_objects         ; is the player carrying:
        cp 0
        jp z, inventory_show_items      ; Yes.  Go show

        ld de,inventory_empty_message   ; Otherwise "Carrying nothing"
        call show_msg
        ret

inventory_show_items:
        ld de,you_carrying_message
        call show_msg

        ;
        ; We know there are items being carried, look for them
        ;
        ld hl, items
        ld b, ITEM_COUNT
inventory_test_item:
        ; hl points to the item
        ; skip past the name
        inc hl
        inc hl
        ; skip past the desc - but save it in DE
        ld e,(hl)
        inc hl
        ld d,(hl)
        inc hl
        ; skip past the long description
        inc hl
        inc hl
        ld a,(hl)
        cp 0xff ; 0xff means the item is being carried
        jr nz, inv_item_not_carried
          push hl
          push de
          push bc
          push af
          call show_msg
          call show_newline
          pop af
          pop bc
          pop de
          pop hl
inv_item_not_carried:
        inc hl
        djnz inventory_test_item
        ret



;
; Command-Handler LOOK
;
; Show the current location.  If the seen-flag has not been set then
; show the long description and set the flag.
;
look_function:
        ld de,LOOK_FUNCTION_PREFIX
        call show_msg
        ld hl, CURRENT_LOCATION  ; get current location
        ld a, (hl)
        ld b, a                  ; multiply by the length of each entry
        ld c, LOCATION_ENTRY_LENGTH
        call multiply
        ld de, location_table ; add to base of location table
        add hl,de

look_function_show:
        ; ok we point to the table - show the short version
        ld e, (hl)
        inc hl
        ld d, (hl)
        inc hl
        push hl
        call show_msg
        call show_newline
        call show_newline
        pop hl

        ld e, (hl)  ; get the long-message address in de
        inc hl
        ld d, (hl)
        inc hl

        ; input-buffer starts with L for look?
        ; then always show
        ld bc, input_buffer+2
        ld a, (bc)
        cp 'L'
        jp z,look_show_extended

        ; otherwise if we've seen this room don't show the
        ; extended description or objects.
        ld a, (hl)
        cp 1
        ret z
look_show_extended:
        push hl
        call show_msg
        pop hl

        ld a, 1
        ld (hl), a    ; set the seen-flag

        call items_are_present
        cp 0
        ret nz

        ld de,you_see_message
        call show_msg


        ;
        ; OK at this point we have looked at the room, and
        ; we want to see the items there.
        ;
        ; Walk over the list of items - and show any which
        ; are present in this room.
        ;
        ld hl, CURRENT_LOCATION
        ld a,(hl)

        ld hl, items
        ld b, ITEM_COUNT
look_item_loop:
        ; hl points to the item
        ; skip past the name
        inc hl
        inc hl
        ; skip past the desc - but save it in DE
        ld e,(hl)
        inc hl
        ld d,(hl)
        inc hl
        ; skip past the long description
        inc hl
        inc hl
;        ld c,(hl)
        cp (hl)
        jr nz, item_not_present
          push hl
          push de
          push bc
          push af
          call show_msg
          call show_newline
          pop af
          pop bc
          pop de
          pop hl
item_not_present:
        inc hl
        djnz look_item_loop
        ret

;
; Command-Handler UP
;
; Change location - TODO fix this
;
up_function:
        ld hl, CURRENT_LOCATION
        dec (hl)
        call look_function
        ret

;
; Command-Handler STUB
;
;  Show that the given command isn't implemented
;
unimplemented_command:
        ld de, unimplemented_command_str
show_msg:
        ld c, BDOS_OUTPUT_STRING
        call BDOS_ENTRY_POINT
        ret

show_newline:
        ld de, NEWLINE
        jp show_msg



;********************************************************************
; Data Storage
;********************************************************************


TURN_COUNT:
        db 0
CURRENT_LOCATION:
        db 0
PLAYER_DEAD:
        db 0
PLAYER_WON:
        db 0
DEBUG_STORE:
        db 0

;********************************************************************
; Data Area
;********************************************************************

NEWLINE:
        db 0x0a, 0x0d, "$"

debug_off_msg:
        db 0x0a, 0x0d, "Debugging turned off.", 0x0a, 0x0d, "$"
debug_on_msg:
        db 0x0a, 0x0d, "Debugging turned on.", 0x0a, 0x0d, "$"
CLS_MSG:
        db 27, "[2J"            ; "clear"
        db 27, "[H"             ; "home"
        db "$"
QUIT_MSG:
        db 0x0a, 0x0d, "You said 'QUIT' so we terminate!", 0x0a, 0x0d, "$"
HELP_MSG:
        db 0x0a, 0x0d, "The following commands are available:", 0x0a, 0x0d, "$"
EXAMINE_WHAT_MSG:
        db 0x0a, 0x0d, "Examine what?", 0x0a, 0x0d, "$"
unimplemented_command_str:
        db 0x0a, 0x0d, "That command is not yet implemented$"
prompt_message:
        db 0x0a, 0x0d,">$"
DEBUG_YOU_ENTERED_MSG:
        db 0x0a, 0x0d, "You entered: $"
DEBUG_AFTER_CASE_CHANGE:
        db 0x0a, 0x0d, "After upper-casing: $"
inventory_empty_message:
        db 0x0a, 0x0d, "You are carrying nothing.", 0x0a, 0x0d, "$"
you_carrying_message:
        db 0x0a, 0x0d, "You are carrying:", 0x0a, 0x0d, "$"
you_see_message:
        db 0x0a, 0x0d, "You see:", 0x0a, 0x0d, "$"
usage_message:
        db "Lighthouse of doom!", 0x0a, 0x0d
        db "===================", 0x0a, 0x0d, 0x0a, 0x0d
        db "This is an original text-based adventure game written for CP/M!"
        db 0x0a, 0x0d
        db 0x0a, 0x0d
        db "Written by Steve Kemp in 2021, with source available on github:"
        db 0x0a, 0x0d
        db 0x0a, 0x0d
        db "  https://github.com/skx/lighthouse-of-doom"
        db 0x0a, 0x0d
        db 0x0a, 0x0d
        db "Bug reports are most welcome, as are puzzle-suggestions and other feedback."
        db 0x0a, 0x0d
        db 0x0a, 0x0d
        db "Any references to the Paw Patrol are entirely deliberate."
        db 0x0a, 0x0d
        db 0x0a, 0x0d
        db 0x0a, 0x0d
        db 0x0a, 0x0d
        db "Press any key to start."
        db 0x0a, 0x0d, "$"

PLAYER_DEAD_MESSAGE:
        db "Game over - you're dead."
        db 0x0a, 0x0d,"$"
PLAYER_WON_MESSAGE:
        db "Game over - you won!"
        db 0x0a, 0x0d,"$"
PLAYER_TURN_COUNT:
        db "You've played $"
PLAYER_TURN_COUNT_END:
        db " turns."
        db 0x0a, 0x0d,"$"
LOOK_FUNCTION_PREFIX:
        db 0x0a, 0x0d, "You are in $"

;
; Location text
;
location_0_short:
        db "the top floor of the lighthouse.$"
location_0_long:
        db "The lighthouse has a spiral staircase which runs from top to bottom.\n"
        db "Through the window you can see the lights of an approach ship, and\n"
        db "you know that it will crash upon the rocks if you can't signal it away.\n"
        db "Too bad the lighthouse light doesn't seem to be working, it looks like\n"
        db "there's a problem with the power.\n"
        db "$"

location_1_short:
        db "the middle floor of the lighthouse.$"
location_1_long:
        db "The middle floor of the lighthouse seems to be a relaxation-room,\n"
        db "you see some comfy chairs, a work-desk, as well as various odds and\n"
        db "ends.\n\n"
        db "An impressive painting hangs over the desk.\n"
        db "$"

location_2_short:
        db "the ground floor of the lighthouse.$"
location_2_long:
        db "The ground floor seems very crowded, with most of the room\n"
        db "taken up by a coat-rack, boots, and similar things\n"
        db "$"


location_3_short:
        db "the lighthouse basement.$"
location_3_long:
        db "This seems to be a graveyard for discarded machinery, and\n"
        db "oddly enough old children's toys.\n"
        db "$"

location_4_short:
        db "a dark place.$"
location_4_long:
        db "You cannot see anything, but you can hear a snarling.\n"
        db "There is also a strong smell, a feral smell, could it be that this\n"
        db "is the haunt of a grue?"
        db "$"


;
; Our command-table contains the commands we accept, a pointer to their
; handlers, and a "hidden" flag.
;
; The HELP command will show all non-hidden commands.
;
; NOTE: There is no help-text for the commands
;
command_table:
        DEFB 3, 'CLS', 1
          DEFW cls_function
        DEFB 4, 'DOWN', 0
          DEFW down_function
        DEFB 4, 'DROP', 0
          DEFW unimplemented_command
        DEFB 7, 'EXAMINE', 0
          DEFW examine_function
        DEFB 3, 'GET', 0
          DEFW unimplemented_command
        DEFB 4, 'HELP', 0
          DEFW help_function
        DEFB 4, 'LOOK', 0
          DEFW look_function
        DEFB 9, 'INVENTORY', 0
          DEFW inventory_function
        DEFB 4, 'OPEN', 0
          DEFW unimplemented_command
        DEFB 4, 'QUIT', 0
          DEFW quit_function
        DEFB 5, 'TURNS', 0
          DEFW show_turn_count
        DEFB 2, 'UP', 0
          DEFW up_function
        DEFB 3, 'USE', 0
          DEFW unimplemented_command
        ;; synonyms
        DEFB 5, 'DEBUG', 1
          DEFW debug_function
        DEFB 4, 'TAKE', 1
          DEFW unimplemented_command
        DEFB 6, 'PICKUP', 1
          DEFW unimplemented_command
        DEFB 4, 'READ', 1
          DEFW unimplemented_command
        ;; easter-eges
        DEFB 4, 'CALL', 1
          DEFW unimplemented_command
        DEFB 4, 'DIAL', 1
          DEFW unimplemented_command
        DEFB 4, 'FUCK', 1
          DEFW unimplemented_command
        DEFB 5, 'PHONE', 1
          DEFW unimplemented_command
        DEFB 4, 'SHIT', 1
          DEFW unimplemented_command
        DEFB 5, 'XYZZY', 1
          DEFW unimplemented_command
        ;; abbreviations
        DEFB 1, 'L', 1
          DEFW look_function
        DEFB 3, 'INV', 1
          DEFW inventory_function
        DEFB 1, 'I', 1
          DEFW inventory_function
        DEFB 1, 'U', 1
          DEFW up_function
        DEFB 1, 'D', 1
          DEFW down_function
        DEFB 0


;
; Location table
;
; Each location contains a pointer to a short-description, a pointer to
; a long description, and a seen-flag.
;
location_table:
        DEFW location_0_short
        DEFW location_0_long
        DB 0 ; seen-flag
location_first:
        DEFW location_1_short
        DEFW location_1_long
        DB 0 ; seen-flag

        DEFW location_2_short
        DEFW location_2_long
        DB 0 ; seen-flag

        DEFW location_3_short
        DEFW location_3_long
        DB 0 ; seen-flag

        DEFW location_4_short
        DEFW location_4_long
        DB 0 ; seen-flag

LOCATION_ENTRY_LENGTH: EQU location_first - location_table

item_0_name: db "GENERATOR"
item_0_desc: db "A small generator.$"
item_0_long: db "This is a diesel-power generator, which seems to be full of fuel, and ready to go."
             db "$"

item_1_name:  db "MIRROR"
item_1_desc:  db "A small mirror.$"
item_1_long:  db "The mirror doesn't seem to be anything special.\n"
              db "But your reflection?  It looks fabulous.\n"
              db "$"

item_2_name:  db "MIRROR-BROKEN"
item_2_desc:  db "A small mirror, which is cracked and broken.$"
item_2_long:  db "The mirror was once small and delicate.\n"
              db "But now it shows a distored reflection of yourself,\n"
              db "which is oddly unsettling.\n"
              db "$"

item_3_name:  db "TORCH"
item_3_desc:  db "A small torch.$"
item_3_long:  db "The torch doesn't seem to be anything special,\n"
              db "but you do notice that it contains batteries and can be turned on easily.\n"
              db "$"

item_4_name:  db "TORCH-LIT"
item_4_desc:  db "A small torch, which is turned on.$"
item_4_long:  db "The torch doesn't seem to be anything special.\n"
              db "$"

;
; Item table
;
; Each item contains:
;
;   1. A pointer to the (internal) name.
;   2. A pointer to a short description - this will be empty for "hidden" items.
;   3. A pointer to a long description
;
;  TODO:
;
;    ptr for get, drop, use, and examine
;
items:
        DEFW item_0_name  ; generator
        DEFW item_0_desc
        DEFW item_0_long
        DEFB 0xff ; player

item_first:
        DEFW item_1_name  ; mirror
        DEFW item_1_desc
        DEFW item_1_long
        DEFB 0x01 ; middle-floor

        DEFW item_2_name  ; mirror-broken
        DEFW item_2_desc
        DEFW item_2_long
        DEFB 0xF0         ; not visible anywhere

        DEFW item_3_name  ; torch
        DEFW item_3_desc
        DEFW item_3_long
        DEFB 0x00         ; top-floor

        DEFW item_4_name  ; torch-lit
        DEFW item_4_desc
        DEFW item_4_long
        DEFB 0xF0         ; not visible anywhere
item_last:


; length of an entry in the item table.
ITEM_ENTRY_LENGTH: EQU item_first - items
ITEM_COUNT: EQU ( item_last - items ) / ITEM_ENTRY_LENGTH


; Temporary buffer, available to all handlers.
; 30 bytes long
tmp_buffer:
        db 0,0, 0,0, 0,0, 0,0, 0,0
        db 0,0, 0,0, 0,0, 0,0, 0,0
        db 0,0, 0,0, 0,0, 0,0, 0,0
tmp_buffer_end:
TMP_BUFFER_LEN: EQU ( tmp_buffer_end - tmp_buffer)


;
; This is the buffer which is used for reading a line of text from the
; CP/M BIOS.
;
; The way this works is you pass the address of a region of memory, the
; first byte is the length of the buffer, the second byte will be populated
; by the amount of text which was read.
;
; After that goes the input itself, obviously.
input_buffer:
        db 100, 0x00
        db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
